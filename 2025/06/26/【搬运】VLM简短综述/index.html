

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jinbiao Zhu">
  <meta name="keywords" content="">
  
    <meta name="description" content="视觉语言模型：基本认识[TOC] 1. 定义和讨论范围定义：“Vision Language Models or VLMs are AI models that use both images and textual data to perform tasks that fundamentally need both of them.” VLM 隶属于 AI 模型，这类 AI 模型使用图像或文本数">
<meta property="og:type" content="article">
<meta property="og:title" content="【搬运】VLM简短综述">
<meta property="og:url" content="http://example.com/2025/06/26/%E3%80%90%E6%90%AC%E8%BF%90%E3%80%91VLM%E7%AE%80%E7%9F%AD%E7%BB%BC%E8%BF%B0/index.html">
<meta property="og:site_name" content="JinbiaoZhu">
<meta property="og:description" content="视觉语言模型：基本认识[TOC] 1. 定义和讨论范围定义：“Vision Language Models or VLMs are AI models that use both images and textual data to perform tasks that fundamentally need both of them.” VLM 隶属于 AI 模型，这类 AI 模型使用图像或文本数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nanonets.com/blog/content/images/2024/09/image-171.png">
<meta property="og:image" content="https://nanonets.com/blog/content/images/2024/09/image-140.png">
<meta property="og:image" content="https://nanonets.com/blog/content/images/2024/09/image-141.png">
<meta property="og:image" content="https://nanonets.com/blog/content/images/2024/09/image-142.png">
<meta property="og:image" content="https://nanonets.com/blog/content/images/2024/09/image-143.png">
<meta property="og:image" content="https://nanonets.com/blog/content/images/2024/09/image-150.png">
<meta property="og:image" content="https://nanonets.com/blog/content/images/2024/09/image-152.png">
<meta property="og:image" content="https://i.imgur.com/IcKbERN.png">
<meta property="og:image" content="https://i.imgur.com/93kXUPG.png">
<meta property="og:image" content="https://nanonets.com/blog/content/images/2024/09/image-155.png">
<meta property="og:image" content="https://i.imgur.com/ULNHUwJ.png">
<meta property="article:published_time" content="2025-06-26T15:20:41.000Z">
<meta property="article:modified_time" content="2025-06-27T05:59:18.725Z">
<meta property="article:author" content="Jinbiao Zhu">
<meta property="article:tag" content="多模态大模型">
<meta property="article:tag" content="综述">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://nanonets.com/blog/content/images/2024/09/image-171.png">
  
  
  
  <title>【搬运】VLM简短综述 - JinbiaoZhu</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>JinbiaoZhu</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">【搬运】VLM简短综述</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-26 23:20" pubdate>
          2025年6月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          58 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【搬运】VLM简短综述</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="视觉语言模型：基本认识"><a href="#视觉语言模型：基本认识" class="headerlink" title="视觉语言模型：基本认识"></a>视觉语言模型：基本认识</h1><p>[TOC]</p>
<h2 id="1-定义和讨论范围"><a href="#1-定义和讨论范围" class="headerlink" title="1. 定义和讨论范围"></a>1. 定义和讨论范围</h2><p>定义：<font color=red>“Vision Language Models or VLMs are AI models that use both images and textual data to perform <u>tasks that fundamentally need both of them</u>.”</font> VLM 隶属于 AI 模型，这类 AI 模型使用图像或文本数据来执行<u>本质上需要这两个模态的任务</u>。</p>
<p>本文讨论的 VLM 特指于 “Our coverage will be exclusive to <u>VLMs that generate text as output</u>.” 也就是以文本<font color=blue>（包括自然语言、数字、代码）</font>为输出的 VLM 模型；而以图像为输出的模型此处不参与讨论。</p>
<h2 id="2-视觉语言模型适用任务"><a href="#2-视觉语言模型适用任务" class="headerlink" title="2. 视觉语言模型适用任务"></a>2. 视觉语言模型适用任务</h2><ol>
<li>Image Captioning: 生成描述图像的文字</li>
<li>Dense Captioning: 生成描述图像的、包含图像中突出特点&#x2F;特性的文字，相比于前者颗粒度更高</li>
<li>Instance Detection: 在图片中使用 bounding box 来标注出检测到的物体</li>
<li>Visual Question Answering (VQA): 针对图片进行文本模态的问与答</li>
<li>Image Retrieval or Text to Image discovery: 从多张图像中找到最匹配输入文本描述的图像</li>
<li>Zero Shot Image classification: 根据文本模态提供的类别信息直接对图像进行分类（无需额外训练）</li>
<li>Synthetic data generation: 根据 VLM 的特性制造合成数据</li>
</ol>
<h2 id="3-视觉语言模型发展历史"><a href="#3-视觉语言模型发展历史" class="headerlink" title="3. 视觉语言模型发展历史"></a>3. 视觉语言模型发展历史</h2><table>
<thead>
<tr>
<th>时间</th>
<th>2015 年前后</th>
<th>2020 年前后</th>
<th>2024年前后</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>出现了两项工作：<a target="_blank" rel="noopener" href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Vinyals_Show_and_Tell_2015_CVPR_paper.pdf">Show and Tell</a> 用于生成图像描述，和<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1505.00468">Visual Question Answering</a> 用于生成视觉问答。</td>
<td>CLIP</td>
<td>ViT 和各种 LLM 的出现问世</td>
</tr>
<tr>
<td>意义</td>
<td>提出构建 VLM 的基本思路：<b>通过调整视觉主干的图像嵌入使其与文本主干兼容，促进视觉和文本表征之间的有效沟通。</b></td>
<td>1. 使用互联网的图文数据；2. 使用对比学习。</td>
<td>二者成为了当前 VLM 的基本组成部分。</td>
</tr>
</tbody></table>
<h2 id="4-视觉语言模型基本网络架构"><a href="#4-视觉语言模型基本网络架构" class="headerlink" title="4. 视觉语言模型基本网络架构"></a>4. 视觉语言模型基本网络架构</h2><p><img src="https://nanonets.com/blog/content/images/2024/09/image-171.png" srcset="/img/loading.gif" lazyload></p>
<p>当前 VLM 的网络架构通常是以下三种：</p>
<ol>
<li><span style="background-color: yellow;">双塔 VLM </span>：视觉网络输出和文本网络输出的唯一连接位于整个 VLM 的最后一层。 </li>
<li><span style="background-color: yellow;">双腿 VLM </span>：单个 LLM 接受文本标记以及来自视觉编码器的标记。</li>
<li><span style="background-color: yellow;">统一&#x2F;单塔 VLM </span>：一个骨干同时处理视觉和文本输入。</li>
</ol>
<h2 id="5-视觉语言模型的模态融合方式"><a href="#5-视觉语言模型的模态融合方式" class="headerlink" title="5. 视觉语言模型的模态融合方式"></a>5. 视觉语言模型的模态融合方式</h2><h3 id="5-1-Shallow-Early-fusion-浅-早期融合"><a href="#5-1-Shallow-Early-fusion-浅-早期融合" class="headerlink" title="5.1 Shallow&#x2F;Early fusion 浅&#x2F;早期融合"></a>5.1 Shallow&#x2F;Early fusion 浅&#x2F;早期融合</h3><p>定义：视觉输入和语言输入之间的连接&#x2F;结合发生<u>在计算过程的早期</u>，这意味着视觉输入<u>在进入文本域之前只经历最少程度的转换</u>，因此称为 “浅” 。</p>
<p>【做法一】确保视觉编码器（vision encoder）输出能够与 LLMs 的输入兼容，并且<font color=red>仅训练视觉编码器，同时保持大语言模型的参数冻结</font>。该架构本质上是一个大语言模型<font color=blue>（通常是 decoder-only 语言模型）</font>，<u>它扩展出一个用于图像编码的分支</u>。这种架构编码实现简单、易于理解，通常不需要编写新的网络层。这类架构的损失函数与普通的大语言模型相同，即<u>关注下一个 token 的预测质量</u>。“Frozen” 就是这类实现的一个示例。除了训练视觉编码器，该方法还采用了 prefix-tuning 技术：为所有视觉输入附加一个静态的前缀 token。这种设置使得视觉编码器可以根据 LLM 对前缀的响应进行自我调整。</p>
<hr>
<p>【做法二】仅使用视觉编码器的问题在于，<font color=red>其输出很难确保与大语言模型（LLM）兼容</font>，从而限制了视觉模型与语言模型的可选组合。更简单的做法是，在视觉网络和语言模型之间加入一个<u>中间层</u><font color=blue>（包括投影层 projector 和适配器 adapter ）</font>，使视觉编码器的输出能够适配 LLM 。通过在两者之间插入中间层，可以将<b>任意</b>视觉嵌入对齐到<b>任意</b>语言模型可以理解的形式。这种架构在灵活性上<u>优于或等同于</u>训练视觉编码器。这样可以选择<u>同时冻结</u>视觉网络和语言模型，同时由于适配器模块通常<u>体积较小</u>，也能<u>加速训练过程</u>。代表的 VLMs 有：</p>
<ol>
<li><p><span style="background-color: yellow;">【简单中间层】</span>Llava 系模型；</p>
</li>
<li><p><span style="background-color: yellow;">【简单中间层】</span>Bunny: 有跨模态中间层 projector 的加持下，视觉输入可以使用多种编码器网络处理；文本输出可以使用多种语言模型产生；使用参数高效指令微调方法（LoRA）训练。</p>
<p><img src="https://nanonets.com/blog/content/images/2024/09/image-140.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p><span style="background-color: yellow;">【简单中间层】</span>MM1: 使用混合专家模型 MoE</p>
</li>
<li><p><span style="background-color: yellow;">【简单中间层】</span>Cobra: 使用 Mamba 架构取代传统 Transformer ，同时使用<u>两个视觉编码器</u>联合提取图像表征。</p>
<p><img src="https://nanonets.com/blog/content/images/2024/09/image-141.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p><span style="background-color: yellow;">【复杂中间层】</span>CLIP Cap: 视觉编码器采用 CLIP + 基于 Transformer 的映射网络，其中 Const. 是可学习常量。</p>
<p><img src="https://nanonets.com/blog/content/images/2024/09/image-142.png" srcset="/img/loading.gif" lazyload> </p>
</li>
<li><p><span style="background-color: yellow;">【复杂中间层】</span>BLIP-2: 使用 Q-Former 作为其中间层 projector ，以更有效地将图像内容与语言进行对齐和关联，实现更强的视觉语义对齐能力。</p>
</li>
<li><p><span style="background-color: yellow;">【复杂中间层】</span>MobileVLMv2: 使用一种基于<u>轻量级逐点卷积（point-wise convolution）</u>的架构，并以 MobileLLama 作为<u>小型语言模型（SLM）</u>替代传统的大语言模型（LLM），重点提升推理速度。</p>
</li>
<li><p><span style="background-color: yellow;">【多中间层联合】</span>BRAVE: 使用最多<b>五</b>个视觉编码器，并采用名为 MEQ-Former 的中间层，将所有视觉输入拼接为一个整体后再送入 VLM ，以实现<u>多视角信息</u>的融合与统一处理。</p>
<p><img src="https://nanonets.com/blog/content/images/2024/09/image-143.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p><span style="background-color: yellow;">【多中间层联合】</span>Honeybee: 使用两个专用的视觉编码器，分别称为 C-Abstractor 和 D-Abstractor。C-Abstractor 注重保持图像的局部性信息，而 D-Abstractor 则具备输出可变数量 token 的能力，从而实现更灵活和精细的视觉信息表达。</p>
</li>
<li><p><span style="background-color: yellow;">【多中间层联合】</span>DeepSeek VL: 同样采用多个编码器，以保留图像中的高层语义信息和低层细节信息。然而，与其他方法不同的是，该模型还对 LLMs 进行联合训练，从而实现深度融合（deep fusion）。</p>
</li>
</ol>
<h3 id="5-2-Late-Fusion-后期融合"><a href="#5-2-Late-Fusion-后期融合" class="headerlink" title="5.2 Late Fusion 后期融合"></a>5.2 Late Fusion 后期融合</h3><p>这类架构中的<font color=red>视觉模型与文本模型是完全分离的</font>。图像和文本的嵌入<u>仅在损失计算阶段进行交互</u>，而这种损失通常是对比损失（contrastive loss）。</p>
<ol>
<li>CLIP 就是这类架构的经典代表，其中图像和文本分别独立编码，通过对比损失进行匹配，从而共同优化各自的编码器。</li>
<li>JINA CLIP 对传统 CLIP 架构进行了改进，不仅联合优化了 CLIP 损失（即 “图像—文本” 对比损失），还引入了 “文本—文本” 对比损失，其中只有语义相近的文本对才被视为相似。这其中的启示是：<span style="background-color: yellow;">通过引入更多的目标函数，可以使多模态对齐更加精准</span>。</li>
<li>ColPali 是另一种典型的后期融合模型，专门用于文档检索。它与 CLIP 略有不同，ColPali 使用视觉编码器与 LLMs 结合来生成视觉嵌入，而文本嵌入则完全依赖于 LLMs 。</li>
<li>ViTamin 训练了一个视觉主干网络，该网络将<u>卷积块</u>与 <u>Transformer 块</u>进行拼接融合，旨在兼具两者的优势，获得更优的视觉特征表示。</li>
</ol>
<h3 id="5-3-Deep-Fusion-深度融合"><a href="#5-3-Deep-Fusion-深度融合" class="headerlink" title="5.3 Deep Fusion 深度融合"></a>5.3 Deep Fusion 深度融合</h3><p>这类架构通常<b>在网络的深层</b>对图像特征进行注意力处理，从而实现更丰富的跨模态知识传递。训练过程一般覆盖所有模态，虽然训练时间较长，但往往能带来更高的效率和准确性。有时，这些架构类似于 Two-Leg VLMs 且 LLM 参数处于非冻结状态。</p>
<ol>
<li><p>CLIPPO 使用单个编码器同时处理视觉输入和文本输入。</p>
</li>
<li><p>Single-tower Transformer: 从头开始训练一个统一的 Transformer，使其能够同时支持多种 VLM 应用任务。</p>
</li>
<li><p>DINO: 在跨模态 Transformer 的基础上引入定位损失（localization loss），实现<u>零样本目标检测</u>，即能够预测训练集中未出现的类别。</p>
</li>
<li><p>KOSMOS-2: 将边界框（bounding boxes）作为输入和输出，与文本和图像的 token 一起处理，将目标检测能力直接内嵌到语言模型中。</p>
</li>
<li><p>Chameleon 通过使用量化器（quantizer）将图像原生地视作 token，从而构建出一种对文本与视觉模态均无偏向的通用架构。</p>
<p><img src="https://nanonets.com/blog/content/images/2024/09/image-150.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>FIBER 通过动态开关交叉注意力模块（cross attention modules）来执行不同任务，实现灵活的功能切换。</p>
</li>
<li><p>BridgeTower 构建了一个独立的跨模态编码器，内置 <u>“桥接层”（bridge-layer）</u>，能够在文本对视觉和视觉对文本的 token 之间进行交叉注意，捕捉更丰富的交互信息。</p>
<p><img src="https://nanonets.com/blog/content/images/2024/09/image-152.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>Flamingo 中，视觉 token 由<u>改进版 ResNet</u> 以及<u>类似 DETR 的专用层 Perceiver Resampler</u> 生成。随后，利用 Chinchilla LLM 作为<u>冻结</u>骨干，通过跨注意力将视觉 token 与语言 token 进行密集融合。</p>
</li>
<li><p>MoE-LLaVa 则采用 MoE 技术处理视觉和文本 token，训练分为两个阶段：首先仅训练前馈网络（FFNs），随后训练大语言模型（LLM）。</p>
</li>
</ol>
<h2 id="6-视觉语言模型的训练过程"><a href="#6-视觉语言模型的训练过程" class="headerlink" title="6. 视觉语言模型的训练过程"></a>6. 视觉语言模型的训练过程</h2><h3 id="6-1-训练目标"><a href="#6-1-训练目标" class="headerlink" title="6.1 训练目标"></a>6.1 训练目标</h3><h4 id="6-1-1-Contrastive-Loss-对比损失"><a href="#6-1-1-Contrastive-Loss-对比损失" class="headerlink" title="6.1.1 Contrastive Loss 对比损失"></a>6.1.1 Contrastive Loss 对比损失</h4><p>这种方法旨在调整<u>嵌入表征</u>，使<font color=red>匹配对之间的距离最小化，而非匹配对之间的距离最大化</font>。这种对比学习方法尤为有效，因为匹配对易于获取，而且还能<b>指数级地</b>增加可用于训练的<b>负样本</b>数量。CLIP 及其各种变体就是采用对比损失进行训练的经典范例，匹配关系发生在图像与文本的嵌入之间。InternVL、BLIP2 和 SigLIP 也是一些值得关注的相关模型。</p>
<p>SLIP 展示了在进行 CLIP 预训练之前，先对视觉编码器进行 “图像—图像” 的对比学习预训练，可以显著提升整体性能。Florence 对对比损失进行了改进，将图像标签和文本的哈希值引入其中，形成了一种称为 Unified-CL 的方法。ColPali 则结合了两种对比损失：一是 “图像—文本” 的对比损失，二是 “文本—文本” 的对比损失。</p>
<h4 id="6-1-2-Generative-Loss-生成式损失"><a href="#6-1-2-Generative-Loss-生成式损失" class="headerlink" title="6.1.2 Generative Loss 生成式损失"></a>6.1.2 Generative Loss 生成式损失</h4><p>这一类损失函数将 VLM 视为生成器，通常用于零样本任务和语言生成任务。</p>
<ul>
<li>语言建模损失（Language Modeling Loss）：这是在训练 VLM 进行下一个 token 预测时最常用的损失函数。Chameleon 对该损失进行了扩展，既用于预测文本 token，也用于预测图像 token。Florence2 则在所有任务中统一使用这种损失函数。</li>
<li>掩码<b>语言</b>建模（Masked Language Modeling, MLM）：通过遮蔽部分文本 token 并让模型在上下文中进行预测，从而训练文本编码器。FIBER 就是使用这一方法的众多模型之一。</li>
<li>掩码<b>图像</b>建模（Masked Image Modeling, MIM）：通过遮蔽输入图像中的一部分 token，让 Transformer 预测被遮蔽的信息，从而迫使模型在有限数据下学习。代表性方法包括：LayoutLM、SegCLIP 中使用的 MAE（Masked Autoencoder）、FLAVA 中采用的 BeiT 等。</li>
<li>掩码<b>图像+文本</b>建模（Masked Image+Text Modeling）：顾名思义，这种方法在图像和文本两个模态中同时进行 token 的遮蔽，以最大限度地在有限数据下促进跨模态交互学习。FLAVA 就是这类方法的代表。</li>
</ul>
<h4 id="6-1-3-Niche-Cross-Modality-Alignments-混合跨模态对齐"><a href="#6-1-3-Niche-Cross-Modality-Alignments-混合跨模态对齐" class="headerlink" title="6.1.3 Niche Cross Modality Alignments 混合跨模态对齐"></a>6.1.3 Niche Cross Modality Alignments 混合跨模态对齐</h4><p>鉴于多模态任务的多样性，研究者常常可以设计出具有针对性的目标函数来实现更精细的模态对齐。例如：</p>
<ul>
<li><b>BLIP2</b> 提出了<u>图像引导的文本生成损失（Image-grounded Text Generation Loss）</u>，通过图像内容引导生成更贴合语义的文本。</li>
<li><b>LayoutLM</b> 使用了一种称为<u>词块对齐（Word Patch Alignment）</u>的机制，用于粗略识别文档中每个词所在的位置，从而将文本与图像中的文档结构进行对齐。</li>
</ul>
<h3 id="6-2-训练视觉语言模型的实践"><a href="#6-2-训练视觉语言模型的实践" class="headerlink" title="6.2 训练视觉语言模型的实践"></a>6.2 训练视觉语言模型的实践</h3><ul>
<li><p>预训练（Pre-training）</p>
<p>在这一阶段，通常仅训练 adapter 或者 projector ，并使用尽可能大量的数据（往往是数百万对 “图像—文本” 对）。目标是使<b>图像编码器与文本解码器对齐</b>，此阶段的重点在于<b>数据量的规模</b>。训练通常是无监督的，常用的损失函数包括 <b>contrastive loss</b> 或 <b>next token prediction loss</b> ，并通过调整输入文本 prompt，使语言模型能更好地理解图像上下文。</p>
</li>
<li><p>微调（Fine-tuning）</p>
<p>根据模型架构的不同，有些或全部模块（适配器、文本模型、视觉模型）从一开始就解冻参与训练。由于参数规模庞大，训练过程会非常缓慢。因此，此阶段使用的数据量通常仅是预训练阶段的一小部分，并且<b>每条数据都需具备极高质量</b>。</p>
</li>
<li><p>指令微调（Instruction Tuning）</p>
<p>这一阶段通常是训练流程中的第二步或第三步，旨在将模型调整为可用于<u>聊天&#x2F;问答</u>等交互式任务。数据会被整理成 “指令—响应” 的格式，常通过现有 LLMs 将普通数据转化为指令形式。<b>LLaVa</b> 和 <b>Vision-Flan</b> 是典型例子。</p>
</li>
<li><p>使用 LoRA（Low-Rank Adaptation）</p>
<p>如前所述，微调过程中可能需要解冻 LLM 参数，而这是一项极其昂贵的操作。LoRA 提供了一种高效替代方案：通过在 LLM 各层之间插入小型的<u>低秩适配层</u>，能够在保持整体调整的同时，只训练 LLM 的一小部分参数，显著降低训练成本。</p>
</li>
<li><p>多分辨率输入（Multiple Resolutions）</p>
<p>在处理包含高密度信息的图像任务时（例如目标计数、拥挤人群识别或 OCR 中文字识别），VLMs 往往面临挑战。因此，支持多分辨率输入成为提高模型鲁棒性和适应能力的一项关键设计。</p>
<p>最简单的方式是将图像调整为多个不同的分辨率，并从每个分辨率中裁剪出所有子图（crops），然后将这些子图输入视觉编码器，并作为 token 喂入 LLM 。这一策略由 Scaling on Scales 提出，并被 Bunny 系列模型广泛采用，该系列在多项任务中表现出色。</p>
<p>LLaVA-UHD 则尝试寻找最优的图像切片（grid 划分）策略，在输入视觉编码器之前对图像进行合理划分。</p>
<p><img src="https://i.imgur.com/IcKbERN.png" srcset="/img/loading.gif" lazyload></p>
<p>InternLMXComposer2-4KHD 采用动态多分辨率策略，将图像在多个分辨率下裁剪得到的所有子图全部输入视觉编码器，从而更充分地捕捉图像中的细节信息。</p>
</li>
</ul>
<h3 id="6-3-训练数据集"><a href="#6-3-训练数据集" class="headerlink" title="6.3 训练数据集"></a>6.3 训练数据集</h3><table>
<thead>
<tr>
<th align="left">数据集名称和年份</th>
<th align="left">图文对数量</th>
<th align="left">数据集描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">WebLI (2022)</td>
<td align="left">12B</td>
<td align="left">基于 109 种语言的，网络爬取得到的，最大数据集之一。<font color=red>这不是公共数据集。</font></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://laion.ai/blog/laion-5b/">LAION-5B</a> (2022)</td>
<td align="left">5.5B</td>
<td align="left">基于互联网上收集得到的图像-文本对。<font color=red>最大的公开可用数据集之一</font>，已被用来实现从头开始预训练 VLMs 。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2311.06242">FLD-5B</a> (2023)</td>
<td align="left">5B</td>
<td align="left">密集描述（dense captions）、OCR 信息以及定位信息（包括分割掩码和多边形轮廓）为构建一个统一的多任务学习模型提供了理想的基础。这种设计有助于模型在处理多种任务时实现知识共享，并显著提升其泛化能力。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/kakaobrain/coyo-dataset">COYO</a> (2022)</td>
<td align="left">700M</td>
<td align="left">另一个重要的数据集。通过图像级和文本级的筛选流程，过滤掉无信息量的图文对。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://laion.ai/blog/laion-coco/">LAION-COCO</a> (2022)</td>
<td align="left">600M</td>
<td align="left">它是 LAION-5B 的一个子集，并使用合成手段生成的图像描述，因为原始的 alt-text 往往并不准确。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2306.16527">Obelics</a> (2023)</td>
<td align="left">141M</td>
<td align="left">该数据集采用<b>对话</b>格式，即图像与文本组成的多轮对话，非常适用于指令预训练和指令微调任务。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2304.06939">MMC4 (Interleaved)</a> (2023)</td>
<td align="left">101M</td>
<td align="left">同样是聊天格式，该数据集还使用<u>线性分配算法（linear assignment algorithm）</u>，借助 CLIP 特征将图像合理地插入到较长的文本中，增强图文之间的上下文关联性。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1503.01817v2">Yahoo Flickr Creative Commons 100 Million (YFCC100M)</a> (2016)</td>
<td align="left">100M</td>
<td align="left">这是最早期的大规模多模态数据集之一。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2103.01913">Wikipedia-based Image Text</a> (2021)</td>
<td align="left">37M</td>
<td align="left">其独特之处在于将图像与百科式知识关联起来。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/google-research-datasets/conceptual-12m">Conceptual Captions (CC12M)</a> (2021)</td>
<td align="left">12M</td>
<td align="left">与多数只关注现实世界物体或事件的数据集不同，它涵盖了更大范围、更具多样性的概念。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2111.11431">Red Caps</a> (2021)</td>
<td align="left">12M</td>
<td align="left">该数据集采集自 Reddit，因此其 captions 反映了真实世界中用户生成的内容，涵盖多种类别，具有更高的真实性与多样性，相比标准数据集更加贴近<u>自然语言</u>使用方式。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://homes.cs.washington.edu/~ranjay/visualgenome/index.html">Visual Genome</a> (2017)</td>
<td align="left">5.4M</td>
<td align="left">该数据集还包含丰富的标注信息，包括物体检测、物体之间的关系、以及场景中物体的属性，使其非常适合用于场景理解与 dense captioning 等任务。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://ai.google.com/research/ConceptualCaptions/download">Conceptual Captions (CC3M)</a> (2018)</td>
<td align="left">3.3M</td>
<td align="left">该数据集更适合微调。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://huggingface.co/datasets/BoyaWu10/Bunny-v1_1-data">Bunny-pretrain-LAION-2M</a> (2024)</td>
<td align="left">2M</td>
<td align="left">该数据集强度 “视觉—文本” 的对齐。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://sharegpt4v.github.io/">ShareGPT4V-PT</a> (2024)</td>
<td align="left">1.2M</td>
<td align="left">该数据集源自 ShareGPT 平台，其 captions 由一个模型生成，而该模型本身是基于 GPT-4V 生成的描述数据进行训练的。这使得数据集中的文本具有较高的语言质量与视觉理解能力，适用于多模态模型的高质量指令微调和评估。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.cs.rice.edu/~vo9/sbucaptions/">SBU Caption</a> (2011)</td>
<td align="left">1M</td>
<td align="left">该数据集采集自 Flickr ，适用于研究日常场景中图像与文本之间的自然对应关系。它以休闲、生活化的图像为主，能够支持模型在处理非专业、真实用户生成内容时的表现与泛化能力。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://cocodataset.org/#home">COCO Caption</a> (2016)</td>
<td align="left">1M</td>
<td align="left">每张图片均有 5 个独立的人类进行描述。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1912.03098">Localized Narratives</a> (2020)</td>
<td align="left">870k</td>
<td align="left">该数据集包含定位到具体物体的描述信息，非常适合用于图像定位（image grounding）等任务。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2402.11684">ALLaVA-Caption-4V</a> (2024)</td>
<td align="left">715k</td>
<td align="left">该数据集的图像描述由 GPT-4V 生成，主要聚焦于图像描述和视觉推理任务。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/haotian-liu/LLaVA">LLava-1.5-PT</a> (2024)</td>
<td align="left">558k</td>
<td align="left">另一个通过调用 GPT-4 生成的数据集，重点在于提供高质量的提示 prompts ，以支持视觉推理和密集描述任务。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2007.00398">DocVQA</a> (2021)</td>
<td align="left">50k</td>
<td align="left">这是一个基于文档的视觉问答数据集，问题主要聚焦于文档内容，因而在金融、法律或行政等领域的信息抽取任务中具有重要价值。</td>
</tr>
</tbody></table>
<h2 id="7-视觉语言模型评估"><a href="#7-视觉语言模型评估" class="headerlink" title="7. 视觉语言模型评估"></a>7. 视觉语言模型评估</h2><ul>
<li><p>MMMU（Massive Multi-discipline Multimodal Understanding and Reasoning）</p>
<p>MMMU 基准测试是当前评估 VLMs 最受欢迎的基准之一。该基准涵盖多个学科领域，旨在测试 VLMs 的泛化能力，确保优秀的 VLMs 能够跨领域表现出稳定性能。该基准主要评估三项核心能力：<u>感知能力（perception）、知识理解（knowledge）和推理能力（reasoning）</u>。评估采用<u>零样本（zero-shot）</u>设定，要求模型在不进行微调或少样本提示的情况下直接生成准确答案，真正考验其泛化和理解能力。MMMU-PRO 是该基准的增强版本，在原有基础上引入了更具挑战性的问题，并剔除了一些仅凭文本输入就能轻松解答的数据点，从而提升了整体评估的难度与区分度。</p>
</li>
<li><p>MME</p>
<p>MME 数据集高度注重质量，所有图像均为精心挑选并人工标注，并确保这些图像和问题在互联网上<b>完全不可获取</b>，以避免 VLMs 在训练阶段意外接触这些样本，从而保障评估的公正性与准确性。该基准包含 <b>14</b> 个子任务，每个任务约含 50 张图像，每个任务的回答均为<b>是&#x2F;否（Yes&#x2F;No）</b>形式。一些典型任务包括：<u>物体是否存在、对知名人物或物品的感知、文本翻译</u>等。每张图像都配有两道问题：一道是正向问题，期望模型回答 “YES” ；一道反向问题，期望模型回答 “NO” 。每个子任务都构成一个独立的评估基准。除此之外，还有两个子聚合基准：认知子基准（Cognition Benchmark）：聚合所有推理类子任务的准确率；感知子基准（Perception Benchmark）：聚合所有感知类子任务的准确率。最终的总体基准得分为上述所有子任务基准的总和，用于全面衡量模型在认知与感知方面的综合能力。</p>
<p><img src="https://i.imgur.com/93kXUPG.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>MMStar</p>
<p>该数据集是从 6 个 VQA 数据集中精挑细选出的一个高质量子集，经过严格筛选以确保以下几点：（1）<u>无法仅凭 LLMs 的文本模态知识作答</u>，图像信息是不可或缺的。（2）<u>问题本身不包含答案</u>，确保图像在回答过程中不是可有可无的。（3）<u>问题与答案的文本内容未直接出现在 LLMs 的训练语料中</u>，防止模型通过记忆作答。与 MME 类似，该数据集强调的是质量而非数量，适用于更严谨和真实的多模态模型评估。</p>
<p><img src="https://nanonets.com/blog/content/images/2024/09/image-155.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>Math-Vista</p>
<p>该基准测试数据集从 31 个不同来源收集并精心整理而成，专注于数学相关问题，涵盖了多种推理类型、任务形式、年级水平和语境场景。其多样性使其成为评估模型在数学理解与推理能力方面的重要工具。</p>
</li>
<li><p>MathVerse</p>
<p>MathVerse 是一个与上述数学基准类似但有所不同的数据集，主要聚焦于更具体的数学领域，如<u>二维几何、三维几何以及解析函数</u>等内容。该数据集更强调视觉与空间推理能力，适用于评估模型在几何与函数理解方面的多模态能力。</p>
</li>
<li><p>AI2D</p>
<p>这是一个高度专注于科学图示的数据集，旨在评估 VLMs 对高级科学概念的理解能力。模型不仅需要解析图中的各个元素，还要理解它们之间的相对位置关系、箭头指向关系，以及每个组成部分所附带的文本信息。该数据集包含 5000 张小学科学图示，配有超过 150,000 条丰富注释、对应的句法解析（syntactic parses），以及 15000 多个多项选择题，为模型提供了全面的科学图示理解和推理评估基准。</p>
<p><img src="https://i.imgur.com/ULNHUwJ.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>ScienceQA</p>
<p>这是另一个面向特定领域的数据集，专门用于评估模型在思维链范式下的表现。它不仅要求模型选择正确的多项选择题答案，还需生成详尽的推理解释，以验证其推理深度和逻辑连贯性。此外，该数据集还测试模型的对话式交互能力，通过输入多段文本和多张图像，评估其在复杂上下文中的理解与应答能力，是对多模态模型综合语言推理与多轮对话处理能力的有力检验。</p>
</li>
<li><p>MM-Vet v2</p>
<p>这是最受欢迎、同时也是<b>体量最小</b>的基准测试之一。该数据集通过评估 “单图—单文本” 和类聊天场景下的多种任务，全面考察模型的以下能力：识别能力、常识与知识理解、空间感知、语言生成、光学字符识别和数学推理能力。在该基准上，InternVL 是开源模型中表现最优秀的之一，再次展现其在多模态理解方面的强大能力。</p>
</li>
<li><p>VisDial</p>
<p>VisDial 一个源自 COCO 数据集的多模态数据集，旨在评估 VLM 聊天机器人在面对一系列图像与文本输入后，对后续问题的回答能力。它更关注于对<u>上下文图文交互的理解与连续对话</u>能力。</p>
</li>
<li><p>LLaVA-NeXT-Interleave</p>
<p>LLaVA-NeXT-Interleave 一个评估模型在多图输入情境下表现的基准测试。它整合了 9 个新数据集和 13 个已有数据集（包括 Muir-Bench 和 ReMI），全面考察模型在处理多张图像时的整合理解能力、跨图推理能力与一致性判断能力。</p>
</li>
<li><p>SEED</p>
<p>具有图像和视频模态的多项选择题。</p>
</li>
<li><p>VQA</p>
<p>最早的数据集之一，覆盖了广泛的日常场景。</p>
</li>
<li><p>GQA</p>
<p>GQA 是一个专注于组合式问答的数据集，其问题通常涉及<u>图像中多个物体之间的关系与属性组合</u>。例如，问题可能要求模型理解 “左边的红色物体是否在蓝色桌子上？” 这类需要多层次推理的问题。GQA 强调模型的<u>逻辑推理能力、结构化理解以及对复杂视觉语义</u>的掌握。</p>
</li>
<li><p>VisWiz</p>
<p>VisWiz 是一个由<b>盲人用户</b>生成的数据集。每位盲人拍摄一张图片<font color=blue>（啊？？？？？？）</font>，并针对该图片录制一段口述提问，随后通过众包方式为每个视觉问题收集了约 10 个答案。该数据集反映了真实用户在视觉辅助场景下的需求，特别适用于评估模型在辅助盲人理解视觉内容方面的能力。</p>
</li>
<li><p>POPE </p>
<p>POPE 是一个有趣的数据集，展示了如何通过简单的构建模块创造复杂的测试场景。它的问题形式主要是判断图像中某些物体的存在或不存在，首先利用目标检测模型识别图像中的物体作为 “存在” 样本，再通过否定方式生成 “缺失” 或 “不存在” 的样本集。该数据集不仅用于考察模型对物体存在性的理解能力，还被用于检测 VLMs 是否出现 “幻觉” 现象，即模型对不存在物体的错误预测。</p>
</li>
</ul>
<h2 id="8-训练-VLMs-需要关注的问题"><a href="#8-训练-VLMs-需要关注的问题" class="headerlink" title="8. 训练 VLMs 需要关注的问题"></a>8. 训练 VLMs 需要关注的问题</h2><h3 id="8-1-明确任务需求"><a href="#8-1-明确任务需求" class="headerlink" title="8.1 明确任务需求"></a>8.1 明确任务需求</h3><ul>
<li>明确模型用途：只做 VQA ？还是需要图像检索、grounding 等功能？</li>
<li>交互方式：单张图片输入还是支持对话式交互？</li>
<li>性能要求：是否实时响应？客户端能否等待？</li>
<li>任务不同，模型大小和架构选择不同。</li>
</ul>
<h3 id="8-2-数据与模型选择"><a href="#8-2-数据与模型选择" class="headerlink" title="8.2 数据与模型选择"></a>8.2 数据与模型选择</h3><ul>
<li>先用现有 SOTA 做 zero-shot 或 one-shot 测试，验证数据适配性。</li>
<li>数据复杂或专业时，评估数据量，决定是从头训练还是微调已有模型。</li>
<li>数据量不足时，考虑用现有 LLMs（GPT、Gemini、Claude等）生成高质量合成数据扩充。</li>
</ul>
<h3 id="8-3-损失函数设计"><a href="#8-3-损失函数设计" class="headerlink" title="8.3 损失函数设计"></a>8.3 损失函数设计</h3><ul>
<li>设计多目标损失函数确保任务被充分表达，借鉴 CLIP 变体、LayoutLM、BLIP-2 等多损失训练方法。</li>
<li>好的损失设计可以显著提升模型效果。</li>
</ul>
<h3 id="8-4-评估与业务指标"><a href="#8-4-评估与业务指标" class="headerlink" title="8.4 评估与业务指标"></a>8.4 评估与业务指标</h3><ul>
<li>选择适合的公开 benchmark 进行评测。</li>
<li>制定符合实际业务需求的指标，不能只依赖损失或 benchmark 成绩。</li>
<li><span style="background-color: yellow;">业务指标才是真正决定模型是否可用的标准</span>。</li>
</ul>
<h3 id="8-5-微调策略"><a href="#8-5-微调策略" class="headerlink" title="8.5 微调策略"></a>8.5 微调策略</h3><ul>
<li>第一阶段只训练 adapter 模块。</li>
<li>第二阶段用 LoRA 技术联合训练视觉编码器和语言模型。</li>
<li>保证数据质量，避免劣质样本拖累训练。</li>
</ul>
<h3 id="8-6-从零训练策略"><a href="#8-6-从零训练策略" class="headerlink" title="8.6 从零训练策略"></a>8.6 从零训练策略</h3><ul>
<li>选择适合领域的骨干网络。</li>
<li>采用多分辨率技术捕捉图像多层次细节。</li>
<li>使用多个视觉编码器融合信息。</li>
<li>对复杂数据，采用 MoE 策略训练语言模型。</li>
</ul>
<h3 id="8-7-高级实践"><a href="#8-7-高级实践" class="headerlink" title="8.7 高级实践"></a>8.7 高级实践</h3><ul>
<li>先训练超大模型（50亿参数以上），再用知识蒸馏（distillation）缩小模型。</li>
<li>试验多种架构组合，形成 “模型家族” ，选择最优组合。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B/" class="print-no-link">#多模态大模型</a>
      
        <a href="/tags/%E7%BB%BC%E8%BF%B0/" class="print-no-link">#综述</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【搬运】VLM简短综述</div>
      <div>http://example.com/2025/06/26/【搬运】VLM简短综述/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jinbiao Zhu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年6月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/25/QwenVL%E7%B3%BB%E5%88%97%E5%A4%9A%E6%A8%A1%E6%80%81%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AF%87/" title="QwenVL系列多模态模型学习笔记-第3篇">
                        <span class="hidden-mobile">QwenVL系列多模态模型学习笔记-第3篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
